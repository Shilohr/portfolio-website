// ===================================
// MAIN JAVASCRIPT - PORTFOLIO WEBSITE
// ===================================

// XSS Protection Utility
function escapeHtml(unsafe) {
    if (unsafe === null || unsafe === undefined) return '';
    return String(unsafe)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;")
        .replace(/\//g, "&#x2F;")
        .replace(/=/g, "&#x3D;");
}

// Global Variables
let currentBackgroundIndex = 0;
let typingTimeout;
let starfieldInterval;
let starfieldAnimationId;
let typingAnimationId;
let csrfToken = null;

// DOM Elements
const pageLoader = document.getElementById('pageLoader');
const backgroundContainer = document.getElementById('backgroundContainer');
const starfield = document.getElementById('starfield');
const typingText = document.getElementById('typingText');
const navMenu = document.getElementById('navMenu');
const mobileMenuToggle = document.getElementById('mobileMenuToggle');

// Configuration
const TITLES = [
    'Software Engineer',
    'Full Stack Developer',
    'Creative Coder',
    'Space Enthusiast',
    'Retro Modernist'
];

const BACKGROUND_IMAGES = [
    '/assets/images/weic2208a.webp',
    '/assets/images/weic2301a.webp',
    '/assets/images/weic2425a.webp',
    '/assets/images/weic2513a.webp'
];

// Initialize on DOM Content Loaded
document.addEventListener('DOMContentLoaded', function() {
    initializeApp();
});

// Main Initialization Function (with Error Boundaries)
async function initializeApp() {
    try {
        console.log('üöÄ Initializing Portfolio App...');
        
        // Initialize core systems with error boundaries
        await initializeWithErrorBoundary('Background System', initBackgroundSystem);
        await initializeWithErrorBoundary('Starfield', initStarfield);
        await initializeWithErrorBoundary('Typing Animation', initTypingAnimation);
        await initializeWithErrorBoundary('Navigation', initNavigation);
        await initializeWithErrorBoundary('Copy Buttons', initCopyButtons);
        await initializeWithErrorBoundary('Scroll Effects', initScrollEffects);
        
        // Initialize CSRF protection
        await initializeWithErrorBoundary('CSRF Protection', initializeCSRFProtection);
        
        // Load dynamic content with error boundaries
        await initializeWithErrorBoundary('Projects', loadProjects);
        await initializeWithErrorBoundary('GitHub Repos', loadGitHubRepos);
        
        // Hide page loader after initialization
        setTimeout(() => {
            hidePageLoader();
        }, 2000);
        
        console.log('‚úÖ Portfolio App Initialized Successfully');
        
    } catch (error) {
        console.error('‚ùå Failed to initialize app:', error);
        showError('Failed to load portfolio. Please refresh the page.');
        
        // Fallback: hide loader anyway to prevent infinite loading
        setTimeout(() => {
            hidePageLoader();
        }, 3000);
    }
}

// CSRF Protection
async function initializeCSRFProtection() {
    try {
        const response = await fetch('/api/csrf-token', { credentials: 'include' });
        if (!response.ok) throw new Error('Failed to fetch CSRF token');
        
        const data = await response.json();
        csrfToken = data.csrfToken;
        
        console.log('üîí CSRF protection initialized');
        
        // Refresh CSRF token periodically (every 30 minutes)
        setInterval(refreshCSRFToken, 30 * 60 * 1000);
        
    } catch (error) {
        console.error('‚ùå Failed to initialize CSRF protection:', error);
        throw error;
    }
}

async function refreshCSRFToken() {
    try {
        const response = await fetch('/api/csrf-token', { credentials: 'include' });
        if (!response.ok) throw new Error('Failed to refresh CSRF token');
        
        const data = await response.json();
        csrfToken = data.csrfToken;
        
        console.log('üîÑ CSRF token refreshed');
        
    } catch (error) {
        console.error('‚ùå Failed to refresh CSRF token:', error);
    }
}

// Enhanced API request helper with CSRF protection
async function makeAPIRequest(url, options = {}) {
    const defaultOptions = {
        headers: {
            'Content-Type': 'application/json',
        },
        credentials: 'include'
    };

    // Add CSRF token to state-changing requests
    if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(options.method?.toUpperCase()) && csrfToken) {
        defaultOptions.headers['X-CSRF-Token'] = csrfToken;
    }

    const mergedOptions = {
        ...defaultOptions,
        ...options,
        headers: {
            ...defaultOptions.headers,
            ...options.headers
        }
    };

    try {
        const response = await fetch(url, mergedOptions);
        
        // Handle CSRF errors specifically
        if (response.status === 403) {
            const errorData = await response.json().catch(() => ({}));
            
            if (errorData.requiresRefresh || errorData.requiresToken) {
                console.warn('üîÑ CSRF token expired, refreshing...');
                await refreshCSRFToken();
                
                // Retry the request with new token
                if (csrfToken) {
                    mergedOptions.headers['X-CSRF-Token'] = csrfToken;
                    return await fetch(url, mergedOptions);
                }
            }
        }
        
        return response;
        
    } catch (error) {
        console.error('‚ùå API request failed:', error);
        throw error;
    }
}

// Error Boundary Helper
async function initializeWithErrorBoundary(name, initFunction) {
    try {
        await initFunction();
        console.log(`‚úÖ ${name} initialized successfully`);
    } catch (error) {
        console.error(`‚ùå Failed to initialize ${name}:`, error);
        // Continue with other initializations
        return false;
    }
    return true;
}

// Page Loader Management
function hidePageLoader() {
    if (pageLoader) {
        pageLoader.classList.add('fade-out');
        setTimeout(() => {
            pageLoader.style.display = 'none';
        }, 1000);
    }
}

// Background System (Optimized with Lazy Loading)
function initBackgroundSystem() {
    if (!backgroundContainer) return;
    
    const images = backgroundContainer.querySelectorAll('.background-image');
    if (images.length === 0) return;
    
    // Set first image as active
    images[0].classList.add('active');
    
    // Initialize lazy loading for other images
    initLazyLoading();
    
    // Start cycling backgrounds
    setInterval(cycleBackground, 8000);
    
    console.log('üåå Background system initialized (with lazy loading)');
}

function initLazyLoading() {
    const lazyImages = document.querySelectorAll('.background-image.lazy');
    
    if ('IntersectionObserver' in window) {
        const imageObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const img = entry.target;
                    img.src = img.dataset.src;
                    img.classList.remove('lazy');
                    imageObserver.unobserve(img);
                }
            });
        });
        
        lazyImages.forEach(img => imageObserver.observe(img));
    } else {
        // Fallback for older browsers
        lazyImages.forEach(img => {
            img.src = img.dataset.src;
            img.classList.remove('lazy');
        });
    }
}

function cycleBackground() {
    const images = backgroundContainer.querySelectorAll('.background-image');
    if (images.length === 0) return;
    
    // Remove active class from current image
    images[currentBackgroundIndex].classList.remove('active');
    
    // Move to next image
    currentBackgroundIndex = (currentBackgroundIndex + 1) % images.length;
    
    // Ensure next image is loaded before making it active
    const nextImage = images[currentBackgroundIndex];
    if (nextImage.classList.contains('lazy')) {
        nextImage.src = nextImage.dataset.src;
        nextImage.classList.remove('lazy');
    }
    
    // Add active class to next image
    nextImage.classList.add('active');
    
    console.log(`üñºÔ∏è Background changed to image ${currentBackgroundIndex + 1}`);
}

// Starfield Effect (Optimized)
function initStarfield() {
    if (!starfield) return;
    
    createStars();
    
    // Use requestAnimationFrame for better performance
    let lastTime = 0;
    const targetFPS = 30; // Reduced from 20ms (50fps) to 33ms (30fps)
    const frameInterval = 1000 / targetFPS;
    
    function animateStars(currentTime) {
        if (currentTime - lastTime >= frameInterval) {
            moveStars();
            lastTime = currentTime;
        }
        starfieldAnimationId = requestAnimationFrame(animateStars);
    }
    
    starfieldAnimationId = requestAnimationFrame(animateStars);
    
    console.log('‚≠ê Starfield initialized (optimized)');
}

function createStars() {
    const starCount = 80; // Reduced from 100 for better performance
    
    for (let i = 0; i < starCount; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.dataset.speed = (Math.random() * 0.5 + 0.1).toString(); // Store speed in dataset
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.width = Math.random() * 3 + 'px';
        star.style.height = star.style.width;
        star.style.animationDelay = Math.random() * 3 + 's';
        star.style.animationDuration = (Math.random() * 3 + 2) + 's';
        
        starfield.appendChild(star);
    }
}

function moveStars() {
    const stars = starfield.querySelectorAll('.star');
    stars.forEach(star => {
        const speed = parseFloat(star.dataset.speed);
        const currentTop = parseFloat(star.style.top);
        const newTop = currentTop + speed;
        
        if (newTop > 100) {
            star.style.top = '-5px';
            star.style.left = Math.random() * 100 + '%';
        } else {
            star.style.top = newTop + '%';
        }
    });
}

// Typing Animation (Optimized with Accessibility)
function initTypingAnimation() {
    if (!typingText) return;
    
    let titleIndex = 0;
    let charIndex = 0;
    let isDeleting = false;
    let lastTypeTime = 0;
    let announcedTitle = '';
    
    function typeTitle(currentTime) {
        if (!lastTypeTime) lastTypeTime = currentTime;
        
        const currentTitle = TITLES[titleIndex];
        const elapsed = currentTime - lastTypeTime;
        
        let typeSpeed = isDeleting ? 50 : 100;
        
        if (!isDeleting && charIndex === currentTitle.length) {
            typeSpeed = 2000; // Pause at end
            isDeleting = true;
            // Announce complete title to screen readers
            if (currentTitle !== announcedTitle) {
                announceToScreenReader(`Current role: ${currentTitle}`);
                announcedTitle = currentTitle;
            }
        } else if (isDeleting && charIndex === 0) {
            isDeleting = false;
            titleIndex = (titleIndex + 1) % TITLES.length;
            typeSpeed = 500; // Pause before new title
        }
        
        if (elapsed >= typeSpeed) {
            if (isDeleting) {
                typingText.textContent = currentTitle.substring(0, charIndex - 1);
                charIndex--;
            } else {
                typingText.textContent = currentTitle.substring(0, charIndex + 1);
                charIndex++;
            }
            
            lastTypeTime = currentTime;
        }
        
        typingAnimationId = requestAnimationFrame(typeTitle);
    }
    
    typingAnimationId = requestAnimationFrame(typeTitle);
    console.log('‚å®Ô∏è Typing animation initialized (optimized with accessibility)');
}

// Navigation System
function initNavigation() {
    // Mobile menu toggle
    if (mobileMenuToggle) {
        mobileMenuToggle.addEventListener('click', toggleMobileMenu);
        mobileMenuToggle.addEventListener('keydown', handleMobileMenuKeydown);
    }
    
    // Smooth scrolling for navigation links
    const navLinks = document.querySelectorAll('.nav-link[href^="#"]');
    navLinks.forEach(link => {
        link.addEventListener('click', handleNavLinkClick);
        link.addEventListener('keydown', handleNavLinkKeydown);
    });
    
    // Update active navigation on scroll
    window.addEventListener('scroll', highlightActiveSection);
    
    // Keyboard navigation for menu
    initKeyboardNavigation();
    
    console.log('üß≠ Navigation system initialized');
}

function toggleMobileMenu() {
    const isActive = navMenu.classList.toggle('active');
    
    // Update ARIA attributes
    if (mobileMenuToggle) {
        mobileMenuToggle.setAttribute('aria-expanded', isActive);
    }
    
    // Animate hamburger menu
    const spans = mobileMenuToggle.querySelectorAll('span');
    spans.forEach((span, index) => {
        if (isActive) {
            if (index === 0) span.style.transform = 'rotate(45deg) translateY(8px)';
            if (index === 1) span.style.opacity = '0';
            if (index === 2) span.style.transform = 'rotate(-45deg) translateY(-8px)';
        } else {
            span.style.transform = '';
            span.style.opacity = '';
        }
    });
    
    // Announce to screen readers
    announceToScreenReader(isActive ? 'Menu opened' : 'Menu closed');
    
    // Focus management for keyboard users
    if (isActive) {
        const firstNavLink = navMenu.querySelector('.nav-link');
        if (firstNavLink) {
            setTimeout(() => firstNavLink.focus(), 100);
        }
    }
}

function handleNavLinkClick(e) {
    e.preventDefault();
    const targetId = e.target.getAttribute('href').substring(1);
    const targetSection = document.getElementById(targetId);
    
    if (targetSection) {
        targetSection.scrollIntoView({
            behavior: 'smooth',
            block: 'start'
        });
        
        // Set focus to the target section for accessibility
        setTimeout(() => {
            const targetHeading = targetSection.querySelector('h1, h2, h3');
            if (targetHeading) {
                targetHeading.setAttribute('tabindex', '-1');
                targetHeading.focus();
                targetHeading.removeAttribute('tabindex');
            }
        }, 500);
        
        // Close mobile menu if open
        if (navMenu.classList.contains('active')) {
            toggleMobileMenu();
        }
    }
}

function highlightActiveSection() {
    const sections = document.querySelectorAll('section[id]');
    const navLinks = document.querySelectorAll('.nav-link[href^="#"]');
    
    let currentSection = '';
    
    sections.forEach(section => {
        const sectionTop = section.offsetTop - 100;
        const sectionHeight = section.offsetHeight;
        
        if (window.scrollY >= sectionTop && window.scrollY < sectionTop + sectionHeight) {
            currentSection = section.getAttribute('id');
        }
    });
    
    navLinks.forEach(link => {
        link.classList.remove('active');
        if (link.getAttribute('href') === `#${currentSection}`) {
            link.classList.add('active');
        }
    });
}

// Copy Buttons
function initCopyButtons() {
    const copyButtons = document.querySelectorAll('.copy-button');
    
    copyButtons.forEach(button => {
        button.addEventListener('click', handleCopyClick);
        button.addEventListener('keydown', handleCopyKeydown);
    });
    
    console.log('üìã Copy buttons initialized');
}

async function handleCopyClick(e) {
    const button = e.target;
    const targetId = button.getAttribute('data-copy');
    const targetElement = document.getElementById(targetId);
    
    if (!targetElement) return;
    
    const textToCopy = targetElement.textContent;
    
    try {
        await navigator.clipboard.writeText(textToCopy);
        
        // Show success state
        const originalText = button.textContent;
        button.textContent = 'Copied!';
        button.classList.add('copied');
        button.setAttribute('aria-label', `${originalText} copied to clipboard`);
        
        // Announce to screen readers
        announceToScreenReader(`${textToCopy} copied to clipboard`);
        
        setTimeout(() => {
            button.textContent = originalText;
            button.classList.remove('copied');
            button.setAttribute('aria-label', originalText);
        }, 2000);
        
        console.log(`üìã Copied to clipboard: ${textToCopy}`);
        
    } catch (error) {
        console.error('‚ùå Failed to copy text:', error);
        showError('Failed to copy text to clipboard');
        announceToScreenReader('Failed to copy text to clipboard');
    }
}

// Scroll Effects
function initScrollEffects() {
    const observerOptions = {
        threshold: 0.1,
        rootMargin: '0px 0px -50px 0px'
    };
    
    const observer = new IntersectionObserver(handleIntersection, observerOptions);
    
    // Observe all sections and cards
    const elementsToObserve = document.querySelectorAll('.section, .project-card, .contact-item');
    elementsToObserve.forEach(element => {
        observer.observe(element);
    });
    
    console.log('üé¨ Scroll effects initialized');
}

function handleIntersection(entries) {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            entry.target.classList.add('animate-fadeInUp');
        }
    });
}

// API Functions
async function loadProjects() {
    try {
        const response = await makeAPIRequest('/api/projects?featured=true&limit=3');
        const data = await handleAPIResponse(response, 'Failed to fetch projects');
        displayProjects(data.projects);
        
        console.log(`üìÅ Loaded ${data.projects.length} featured projects`);
        
    } catch (error) {
        console.error('‚ùå Error loading projects:', error);
        displayProjectsError();
    }
}

function displayProjects(projects) {
    const projectsGrid = document.getElementById('projectsGrid');
    if (!projectsGrid) return;
    
    if (projects.length === 0) {
        projectsGrid.innerHTML = '<p class="text-center" role="status">No projects found.</p>';
        announceToScreenReader('No projects found');
        return;
    }
    
    projectsGrid.innerHTML = projects.map((project, index) => `
        <div class="project-card" tabindex="0" role="article" aria-labelledby="project-title-${index}" aria-describedby="project-desc-${index}">
            <h3 class="project-title" id="project-title-${index}">${escapeHtml(project.title)}</h3>
            <p class="project-description" id="project-desc-${index}">${escapeHtml(project.description || 'No description available.')}</p>
            <div class="project-technologies" role="list" aria-label="Technologies used">
                ${project.technologies.map(tech => `<span class="tech-tag" role="listitem">${escapeHtml(tech)}</span>`).join('')}
            </div>
            <div class="project-links" role="group" aria-label="Project links">
                ${project.github_url ? `<a href="${escapeHtml(project.github_url)}" target="_blank" class="project-link" rel="noopener noreferrer" aria-label="View ${escapeHtml(project.title)} on GitHub">GitHub</a>` : ''}
                ${project.live_url ? `<a href="${escapeHtml(project.live_url)}" target="_blank" class="project-link" rel="noopener noreferrer" aria-label="View live demo of ${escapeHtml(project.title)}">Live Demo</a>` : ''}
            </div>
        </div>
    `).join('');
    
    announceToScreenReader(`Loaded ${projects.length} projects`);
}

function displayProjectsError() {
    const projectsGrid = document.getElementById('projectsGrid');
    if (projectsGrid) {
        projectsGrid.innerHTML = '<p class="text-center" role="alert">Failed to load projects. Please try again later.</p>';
        announceToScreenReader('Failed to load projects');
    }
}

async function loadGitHubRepos() {
    try {
        const response = await makeAPIRequest('/api/github/repos?limit=6');
        const data = await handleAPIResponse(response, 'Failed to fetch GitHub repos');
        displayGitHubRepos(data.repositories);
        
        console.log(`üêô Loaded ${data.repositories.length} GitHub repositories`);
        
    } catch (error) {
        console.error('‚ùå Error loading GitHub repos:', error);
        displayGitHubError();
    }
}

function displayGitHubRepos(repos) {
    const githubContainer = document.getElementById('githubContainer');
    if (!githubContainer) return;
    
    if (repos.length === 0) {
        githubContainer.innerHTML = '<p class="text-center" role="status">No repositories found.</p>';
        announceToScreenReader('No GitHub repositories found');
        return;
    }
    
    githubContainer.innerHTML = `
        <div class="projects-grid" role="list" aria-label="GitHub repositories">
            ${repos.map((repo, index) => `
                <div class="project-card" tabindex="0" role="listitem" aria-labelledby="repo-title-${index}" aria-describedby="repo-desc-${index}">
                    <h3 class="project-title" id="repo-title-${index}">${escapeHtml(repo.name)}</h3>
                    <p class="project-description" id="repo-desc-${index}">${escapeHtml(repo.description || 'No description available.')}</p>
                    <div class="project-technologies" role="list" aria-label="Repository statistics">
                        ${repo.language ? `<span class="tech-tag" role="listitem">${escapeHtml(repo.language)}</span>` : ''}
                        <span class="tech-tag" role="listitem" aria-label="${repo.stars} stars">‚≠ê ${repo.stars}</span>
                        <span class="tech-tag" role="listitem" aria-label="${repo.forks} forks">üç¥ ${repo.forks}</span>
                    </div>
                    <div class="project-links" role="group" aria-label="Repository links">
                        <a href="${escapeHtml(repo.html_url)}" target="_blank" class="project-link" rel="noopener noreferrer" aria-label="View ${escapeHtml(repo.name)} repository on GitHub">View on GitHub</a>
                    </div>
                </div>
            `).join('')}
        </div>
    `;
    
    announceToScreenReader(`Loaded ${repos.length} GitHub repositories`);
}

function displayGitHubError() {
    const githubContainer = document.getElementById('githubContainer');
    if (githubContainer) {
        githubContainer.innerHTML = '<p class="text-center" role="alert">Failed to load GitHub repositories. Please try again later.</p>';
        announceToScreenReader('Failed to load GitHub repositories');
    }
}

// GitHub Sync Button
const syncGithubBtn = document.getElementById('syncGithub');
if (syncGithubBtn) {
    syncGithubBtn.addEventListener('click', async () => {
        try {
            const originalText = syncGithubBtn.textContent;
            syncGithubBtn.textContent = 'Syncing...';
            syncGithubBtn.disabled = true;
            syncGithubBtn.setAttribute('aria-label', 'Syncing GitHub repositories...');
            
            announceToScreenReader('Syncing GitHub repositories...');
            
            const response = await makeAPIRequest('/api/github/sync', { method: 'POST' });
            const data = await handleAPIResponse(response, 'Failed to sync GitHub');
            console.log('‚úÖ GitHub sync successful:', data);
            
            // Reload repositories
            await loadGitHubRepos();
            
            syncGithubBtn.textContent = 'Sync Complete!';
            syncGithubBtn.setAttribute('aria-label', 'GitHub sync completed successfully');
            announceToScreenReader('GitHub sync completed successfully');
            
            setTimeout(() => {
                syncGithubBtn.textContent = originalText;
                syncGithubBtn.disabled = false;
                syncGithubBtn.setAttribute('aria-label', 'Sync GitHub repositories');
            }, 2000);
            
        } catch (error) {
            console.error('‚ùå GitHub sync error:', error);
            syncGithubBtn.textContent = 'Sync Failed';
            syncGithubBtn.setAttribute('aria-label', 'GitHub sync failed');
            announceToScreenReader('GitHub sync failed');
            
            setTimeout(() => {
                syncGithubBtn.textContent = 'Sync GitHub';
                syncGithubBtn.disabled = false;
                syncGithubBtn.setAttribute('aria-label', 'Sync GitHub repositories');
            }, 2000);
        }
    });
    
    // Add keyboard support
    syncGithubBtn.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            syncGithubBtn.click();
        }
    });
}

// Authentication helper with CSRF protection
async function authenticateRequest(url, options = {}) {
    // Tokens are now stored in httpOnly cookies
    return await makeAPIRequest(url, options);
}

// Logout function with CSRF protection
async function logout() {
    try {
        const response = await authenticateRequest('/api/auth/logout', { method: 'POST' });
        if (!response.ok) throw new Error('Failed to logout');
        
        // Clear local storage (non-sensitive data only)
        localStorage.removeItem('user');
        
        // Redirect to login page or reload
        window.location.reload();
        
    } catch (error) {
        console.error('‚ùå Logout error:', error);
        showError('Failed to logout. Please try again.');
    }
}

// Enhanced error handling for API responses
async function handleAPIResponse(response, errorMessage = 'API request failed') {
    if (!response.ok) {
        // Try to parse error response
        let errorData;
        try {
            errorData = await response.json();
        } catch (e) {
            errorData = { error: errorMessage };
        }
        
        // Handle CSRF errors specifically
        if (response.status === 403) {
            const isCSRFError = handleCSRFError({ response: { data: errorData } }, response);
            if (isCSRFError) {
                throw new Error('CSRF validation failed');
            }
        }
        
        throw new Error(errorData.error || errorMessage);
    }
    
    return await response.json();
}

// Enhanced error handling for CSRF-related issues
function handleCSRFError(error, response) {
    if (response && response.status === 403) {
        const errorData = error.response?.data || {};
        
        if (errorData.requiresRefresh) {
            showError('Session expired. Please refresh the page.');
            announceToScreenReader('Security validation failed. Please refresh the page.');
        } else if (errorData.requiresToken) {
            showError('Security token required. Please refresh the page.');
            announceToScreenReader('Security token required. Please refresh the page.');
        } else {
            showError('Security validation failed. Please refresh the page.');
            announceToScreenReader('Security validation failed. Please refresh the page.');
        }
        return true; // Error was handled as CSRF-related
    }
    return false; // Not a CSRF error
}

// Utility Functions
function showError(message) {
    // Create error toast
    const errorToast = document.createElement('div');
    errorToast.className = 'error-toast';
    errorToast.setAttribute('role', 'alert');
    errorToast.setAttribute('aria-live', 'assertive');
    errorToast.textContent = message;
    errorToast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: var(--warning);
        color: white;
        padding: 1rem;
        border-radius: 8px;
        z-index: 10000;
        max-width: 300px;
        animation: slideInRight 0.3s ease-out;
    `;
    
    document.body.appendChild(errorToast);
    
    // Also announce to screen readers
    announceToScreenReader(`Error: ${message}`);
    
    setTimeout(() => {
        errorToast.style.animation = 'fadeOut 0.3s ease-out';
        setTimeout(() => {
            if (document.body.contains(errorToast)) {
                document.body.removeChild(errorToast);
            }
        }, 300);
    }, 3000);
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (typingTimeout) clearTimeout(typingTimeout);
    if (starfieldInterval) clearInterval(starfieldInterval);
    if (starfieldAnimationId) cancelAnimationFrame(starfieldAnimationId);
    if (typingAnimationId) cancelAnimationFrame(typingAnimationId);
});

// Error handling
window.addEventListener('error', (e) => {
    console.error('‚ùå JavaScript error:', e.error);
});

window.addEventListener('unhandledrejection', (e) => {
    console.error('‚ùå Unhandled promise rejection:', e.reason);
});

// Keyboard Navigation Functions
function handleMobileMenuKeydown(e) {
    if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        toggleMobileMenu();
    }
}

function handleNavLinkKeydown(e) {
    if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        handleNavLinkClick(e);
    }
}

function handleCopyKeydown(e) {
    if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        handleCopyClick(e);
    }
}

function initKeyboardNavigation() {
    // Add keyboard navigation for project cards
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            // Close mobile menu if open
            if (navMenu && navMenu.classList.contains('active')) {
                toggleMobileMenu();
                mobileMenuToggle.focus();
            }
            
            // Close any open modals
            const openModal = document.querySelector('.project-modal.active');
            if (openModal) {
                closeModal(openModal);
            }
        }
    });
    
    // Add keyboard navigation for focusable elements
    const focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Tab') {
            // Let browser handle tab navigation
            return;
        }
    });
}

// Screen Reader Announcements
function announceToScreenReader(message) {
    const announcement = document.createElement('div');
    announcement.setAttribute('role', 'status');
    announcement.setAttribute('aria-live', 'polite');
    announcement.className = 'sr-only';
    announcement.textContent = message;
    
    document.body.appendChild(announcement);
    
    setTimeout(() => {
        document.body.removeChild(announcement);
    }, 1000);
}

// Modal Accessibility Functions
function openModal(modal) {
    if (!modal) return;
    
    modal.setAttribute('aria-hidden', 'false');
    modal.classList.add('active');
    
    // Focus management
    const focusableElements = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    const firstFocusable = focusableElements[0];
    const lastFocusable = focusableElements[focusableElements.length - 1];
    
    if (firstFocusable) {
        firstFocusable.focus();
    }
    
    // Trap focus within modal
    modal.addEventListener('keydown', (e) => {
        if (e.key === 'Tab') {
            if (e.shiftKey) {
                if (document.activeElement === firstFocusable) {
                    e.preventDefault();
                    lastFocusable.focus();
                }
            } else {
                if (document.activeElement === lastFocusable) {
                    e.preventDefault();
                    firstFocusable.focus();
                }
            }
        }
    });
    
    // Prevent body scroll
    document.body.style.overflow = 'hidden';
    
    announceToScreenReader('Modal opened');
}

function closeModal(modal) {
    if (!modal) return;
    
    modal.setAttribute('aria-hidden', 'true');
    modal.classList.remove('active');
    
    // Restore body scroll
    document.body.style.overflow = '';
    
    // Return focus to trigger element
    const trigger = document.querySelector('[data-modal-target]');
    if (trigger) {
        trigger.focus();
    }
    
    announceToScreenReader('Modal closed');
}

console.log('üåü Portfolio script loaded successfully');